<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CCTV Viewer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: Arial, sans-serif;
        background-color: #1a1a1a;
        color: white;
        height: 100vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      .container {
        flex: 1;
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      .video-grid {
        flex: 1;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(2, 1fr);
        gap: 10px;
        padding: 10px;
        min-height: 0;
        overflow: auto;
      }

      .video-container {
        background-color: #2a2a2a;
        border-radius: 4px;
        padding: 5px;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-width: 200px;
        position: relative;
        aspect-ratio: 16 / 9;
        height: auto;
      }

      .video-container:hover {
        background-color: #3a3a3a;
      }

      .video-container.zoomed {
        grid-column: 1 / -1;
        grid-row: 1 / -1;
        z-index: 1000;
        min-height: unset;
        aspect-ratio: unset;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #111;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0;
        padding: 0;
      }

      .video-container.zoomed video {
        object-fit: contain !important;
        width: 100%;
        height: 100%;
        border-radius: 0;
        max-width: 100vw;
        max-height: 100vh;
      }

      video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 2px;
        background-color: #000;
        flex: 1;
        min-height: unset;
      }

      .caption {
        position: static;
        margin-top: 8px;
        margin-bottom: 4px;
        padding: 4px 12px;
        font-size: 15px;
        font-weight: bold;
        text-align: center;
        background: rgba(0, 0, 0, 0.7);
        border-radius: 6px;
        color: #fff;
        z-index: 5;
        white-space: nowrap;
        text-shadow: 0 2px 6px rgba(0, 0, 0, 0.7), 0 1px 1px rgba(0, 0, 0, 0.5);
        pointer-events: none;
        display: block;
      }

      .video-container.zoomed .caption {
        display: none;
      }

      .controls {
        background-color: #2a2a2a;
        border-radius: 8px 8px 0 0;
        padding: 15px;
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: nowrap;
        position: sticky;
        bottom: 0;
        z-index: 100;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.3);
        flex-direction: row;
        justify-content: flex-start;
      }

      .controls .left-group {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .controls .speed-buttons {
        display: flex;
        align-items: center;
        gap: 4px;
        margin-left: 10px;
      }

      .controls .scrubber-container {
        display: flex;
        align-items: center;
        gap: 10px;
        flex: 1;
        min-width: 200px;
      }

      .controls .scrubber {
        flex: 1;
        min-width: 120px;
      }

      .controls .time-display {
        font-family: monospace;
        font-size: 14px;
        min-width: 120px;
        text-align: center;
        flex-shrink: 0;
      }

      /* When any video is zoomed, make controls overlay on top */
      body.video-zoomed .controls {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 1002;
        border-radius: 0;
        background-color: rgba(42, 42, 42, 0.95);
        backdrop-filter: blur(10px);
      }

      .control-btn {
        background-color: #4a4a4a;
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s;
        flex-shrink: 0;
      }

      .control-btn:hover {
        background-color: #5a5a5a;
      }

      .control-btn:active {
        background-color: #3a3a3a;
      }

      .play-pause {
        background-color: #007acc;
        min-width: 60px;
        width: 60px;
      }

      .play-pause:hover {
        background-color: #005a99;
      }

      .speed-btn {
        min-width: 50px;
      }

      .speed-btn.active {
        background-color: #007acc;
      }

      .speed-btn.active:hover {
        background-color: #005a99;
      }

      input[type='range'] {
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: #4a4a4a;
        outline: none;
        -webkit-appearance: none;
        background: linear-gradient(
          to right,
          #4a4a4a 0%,
          #4a4a4a 50%,
          #ff6b35 50%,
          #ff6b35 55%,
          #ff4500 55%,
          #ff4500 59.2%,
          #ff6b35 59.2%,
          #ff6b35 65%,
          #4a4a4a 65%,
          #4a4a4a 100%
        );
      }

      input[type='range']::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #007acc;
        cursor: pointer;
      }

      input[type='range']::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #007acc;
        cursor: pointer;
        border: none;
      }

      input[type='range']::-moz-range-track {
        background: linear-gradient(
          to right,
          #4a4a4a 0%,
          #4a4a4a 50%,
          #ff6b35 50%,
          #ff6b35 55%,
          #ff4500 55%,
          #ff4500 59.2%,
          #ff6b35 59.2%,
          #ff6b35 65%,
          #4a4a4a 65%,
          #4a4a4a 100%
        );
        height: 6px;
        border-radius: 3px;
        border: none;
      }

      .hidden {
        display: none !important;
      }

      /* Mobile responsive design */
      @media (max-width: 768px) {
        html,
        body {
          height: auto;
          min-height: 100vh;
          overflow-y: auto;
        }
        .container {
          height: auto;
          min-height: unset;
          overflow: visible;
        }
        .video-grid {
          grid-template-columns: 1fr;
          grid-template-rows: repeat(6, 1fr);
          gap: 6px;
          padding: 6px;
          padding-bottom: 120px; /* Increased space for new control layout */
          height: auto;
          min-height: unset;
        }

        .video-container {
          min-height: 150px;
          min-width: 150px;
          padding: 3px;
          border-radius: 3px;
          position: relative;
        }

        .video-container .caption {
          position: absolute;
          left: 50%;
          bottom: 8px;
          transform: translateX(-50%);
          font-size: 13px;
          padding: 3px 8px;
          background: rgba(0, 0, 0, 0.7);
          border-radius: 6px;
          color: #fff;
          z-index: 10;
          pointer-events: none;
          display: block;
          margin: 0;
        }

        .video-container.zoomed {
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          min-height: unset;
          background: #111;
          aspect-ratio: unset;
          z-index: 1000;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .video-container.zoomed .caption {
          display: none;
        }

        .video-container .panel-region {
          display: none;
        }

        video {
          min-height: 120px;
          border-radius: 2px;
        }

        .controls {
          flex-direction: column;
          align-items: stretch;
          position: fixed;
          left: 0;
          right: 0;
          bottom: 0;
          z-index: 100;
          padding: 10px;
          gap: 8px;
          border-radius: 0;
          background-color: rgba(42, 42, 42, 0.95);
          backdrop-filter: blur(10px);
        }

        .controls .player-buttons {
          justify-content: center;
          width: 100%;
          margin-bottom: 0;
        }

        .controls .scrubber-container {
          width: 100%;
          display: flex;
          align-items: center;
          gap: 10px;
          margin-bottom: 10px;
          order: 1;
        }

        .controls .time-display {
          font-size: 12px;
          min-width: 80px;
        }

        .controls .left-group {
          width: 100%;
          justify-content: center;
          gap: 10px;
          order: 2;
        }

        .controls .speed-buttons {
          margin-left: 0;
        }

        .control-btn {
          padding: 6px 10px;
          font-size: 12px;
        }

        .speed-btn {
          min-width: 40px;
        }
      }

      /* Tablet responsive design */
      @media (min-width: 769px) and (max-width: 1024px) {
        .video-grid {
          grid-template-columns: repeat(2, 1fr);
          grid-template-rows: repeat(3, 1fr);
          gap: 8px;
          padding: 8px;
        }

        .video-container {
          min-height: 180px;
          min-width: 180px;
          padding: 4px;
          border-radius: 3px;
        }

        .video-container.zoomed {
          grid-column: 1 / -1;
          grid-row: 1 / -1;
          min-height: 350px;
        }

        video {
          min-height: 140px;
          border-radius: 2px;
        }

        .caption {
          font-size: 11px;
          padding: 3px 6px;
          bottom: 8px;
        }
      }

      .zoom-pan-wrapper {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        position: relative;
      }

      .video-container.zoomed .zoom-pan-wrapper {
        width: 100vw;
        height: 100vh;
        background: #111;
        display: flex;
        align-items: center;
        justify-content: center;
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        cursor: default;
      }

      .video-container.zoomed .zoom-pan-wrapper.can-pan {
        cursor: grab;
      }

      .video-container.zoomed .zoom-pan-wrapper.can-pan:active {
        cursor: grabbing;
      }

      .video-container.zoomed video {
        object-fit: contain !important;
        width: 100%;
        height: 100%;
        border-radius: 0;
        max-width: 100vw;
        max-height: 100vh;
      }

      .minimize-btn {
        display: none;
        position: absolute;
        top: 16px;
        right: 16px;
        z-index: 1001;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        border: none;
        border-radius: 50%;
        width: 36px;
        height: 36px;
        font-size: 24px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        transition: background 0.2s;
      }
      .minimize-btn:hover {
        background: rgba(0, 0, 0, 0.9);
      }
      .video-container.zoomed .minimize-btn {
        display: block;
      }

      .sync-indicator {
        position: absolute;
        top: 8px;
        left: 8px;
        background: rgba(255, 107, 53, 0.9);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: bold;
        z-index: 10;
        opacity: 0;
        transition: opacity 0.3s ease;
        pointer-events: none;
      }

      .video-container.syncing .sync-indicator {
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="video-grid">
        <div class="video-container" data-camera="Latura.E-S">
          <button class="minimize-btn" title="Minimizează">&times;</button>
          <div class="sync-indicator">Sincronizare...</div>
          <div class="zoom-pan-wrapper">
            <video class="focus-ur" src="Latura.E-S.mp4" preload="metadata">
              Your browser does not support the video tag.
            </video>
          </div>
          <div class="panel-region panel-region-ur"></div>
          <div class="caption">Latura.E-S</div>
        </div>

        <div class="video-container" data-camera="Latura.V2-S">
          <button class="minimize-btn" title="Minimizează">&times;</button>
          <div class="sync-indicator">Sincronizare...</div>
          <div class="zoom-pan-wrapper">
            <video class="focus-uc" src="Latura.V2-S.mp4" preload="metadata">
              Your browser does not support the video tag.
            </video>
          </div>
          <div class="panel-region panel-region-uc"></div>
          <div class="caption">Latura.V2-S</div>
        </div>

        <div class="video-container" data-camera="Latura.V1-N">
          <button class="minimize-btn" title="Minimizează">&times;</button>
          <div class="sync-indicator">Sincronizare...</div>
          <div class="zoom-pan-wrapper">
            <video class="focus-ur" src="Latura.V1-N.mp4" preload="metadata">
              Your browser does not support the video tag.
            </video>
          </div>
          <div class="panel-region panel-region-ur"></div>
          <div class="caption">Latura.V1-N</div>
        </div>

        <div class="video-container" data-camera="Colt.SV-N">
          <button class="minimize-btn" title="Minimizează">&times;</button>
          <div class="sync-indicator">Sincronizare...</div>
          <div class="zoom-pan-wrapper">
            <video class="focus-ur" src="Colt.SV-N.mp4" preload="metadata">
              Your browser does not support the video tag.
            </video>
          </div>
          <div class="panel-region panel-region-ur"></div>
          <div class="caption">Colt.SV-N</div>
        </div>

        <div class="video-container" data-camera="Colt.SE-V">
          <button class="minimize-btn" title="Minimizează">&times;</button>
          <div class="sync-indicator">Sincronizare...</div>
          <div class="zoom-pan-wrapper">
            <video class="focus-urc" src="Colt.SE-V.mp4" preload="metadata">
              Your browser does not support the video tag.
            </video>
          </div>
          <div class="panel-region panel-region-urc"></div>
          <div class="caption">Colt.SE-V</div>
        </div>

        <div class="video-container" data-camera="Poarta-N">
          <button class="minimize-btn" title="Minimizează">&times;</button>
          <div class="sync-indicator">Sincronizare...</div>
          <div class="zoom-pan-wrapper">
            <video class="focus-urc" src="Poarta-N.mp4" preload="metadata">
              Your browser does not support the video tag.
            </video>
          </div>
          <div class="panel-region panel-region-urc"></div>
          <div class="caption">Poarta-N</div>
        </div>
      </div>
    </div>

    <div class="controls">
      <div class="left-group">
        <button class="control-btn" id="rewindBtn">« 15 s</button>
        <button class="control-btn play-pause" id="playPauseBtn">Redă</button>
        <button class="control-btn" id="forwardBtn">15 s »</button>
        <div class="speed-buttons">
          <button class="control-btn speed-btn" data-speed="0.5">0.5x</button>
          <button class="control-btn speed-btn active" data-speed="1">
            1x
          </button>
        </div>
      </div>
      <div class="scrubber-container">
        <input
          type="range"
          class="scrubber"
          id="scrubber"
          min="0"
          max="100"
          value="0"
          step="0.1"
        />
        <div class="time-display" id="timeDisplay">00:00 / 00:00</div>
      </div>
    </div>

    <script>
      class CCTVViewer {
        constructor() {
          this.videos = Array.from(document.querySelectorAll('video'));
          this.videoContainers = Array.from(
            document.querySelectorAll('.video-container')
          );
          this.playPauseBtn = document.getElementById('playPauseBtn');
          this.rewindBtn = document.getElementById('rewindBtn');
          this.forwardBtn = document.getElementById('forwardBtn');
          this.speedButtons = Array.from(
            document.querySelectorAll('.speed-btn')
          );
          this.scrubber = document.getElementById('scrubber');
          this.timeDisplay = document.getElementById('timeDisplay');

          this.isPlaying = false;
          this.zoomedVideo = null;
          this.isSeeking = false; // Simplified flag for seeking operations
          this.masterVideo = null; // Master video for synchronization
          this.syncOffsets = new Map(); // Simple time offsets for each video
          this.commonDuration = 600; // 10 minutes in seconds (11:25-11:35)
          this.currentSpeed = 1;

          // For zoom/pan
          this.zoomScale = 1;
          this.zoomMin = 1;
          this.zoomMax = 5;
          this.zoomPan = { x: 0, y: 0 };
          this.isPanning = false;
          this.panStart = { x: 0, y: 0 };
          this.panOrigin = { x: 0, y: 0 };
          this.lastTouchDistance = null;
          this._panTimeout = null;
          this._clickTimeout = null;

          // Sync monitoring - much more responsive
          this.lastSyncCheck = 0;
          this.syncCheckInterval = 1000; // Check sync every 1 second for faster response
          this.syncTolerance = 1.5; // More tolerant - 1.5 seconds difference
          this.lastVideoTimes = new Map(); // Track last known times for stuck detection
          this.stuckDetectionThreshold = 2000; // 2 seconds without progress = stuck (reduced from 5s)
          this.lastCorrectionTime = 0; // Track when last correction was made
          this.correctionCooldown = 5000; // 5 seconds between corrections (reduced from 10s)

          this.initializeVideos();
          this.setupEventListeners();
        }

        initializeVideos() {
          // Wait for all videos to load metadata
          Promise.all(
            this.videos.map((video) => {
              return new Promise((resolve) => {
                if (video.readyState >= 1) {
                  resolve();
                } else {
                  video.addEventListener('loadedmetadata', resolve, {
                    once: true,
                  });
                }
              });
            })
          ).then(() => {
            this.setupSyncOffsets();
            this.setupMasterVideo();
            this.setupTimeUpdateListeners();
            this.seekToStart();
            this.updateTimeDisplay();
          });
        }

        setupSyncOffsets() {
          // Simple time offsets for each video (in seconds)
          // These represent when each video should start relative to the master timeline
          const offsets = {
            'Latura.E-S': 3.15, // 63 frames at 20fps
            'Latura.V2-S': 0.55, // 11 frames at 20fps
            'Latura.V1-N': 0, // Reference video
            'Colt.SV-N': 2.4, // 48 frames at 20fps
            'Colt.SE-V': 3.35, // 67 frames at 20fps
            'Poarta-N': 12.1, // 242 frames at 20fps
          };

          this.videos.forEach((video) => {
            const container = video.closest('.video-container');
            const cameraName = container.getAttribute('data-camera');
            this.syncOffsets.set(video, offsets[cameraName] || 0);
          });

          console.log('Sync offsets set:', this.syncOffsets);
        }

        setupMasterVideo() {
          // Use Latura.V1-N as the master video (has offset 0)
          this.masterVideo = this.videos.find((video) => {
            const container = video.closest('.video-container');
            return container.getAttribute('data-camera') === 'Latura.V1-N';
          });

          if (!this.masterVideo) {
            this.masterVideo = this.videos[0]; // Fallback
          }

          console.log('Master video set:', this.masterVideo);
        }

        getMasterTime() {
          if (!this.masterVideo) return 0;
          return this.masterVideo.currentTime;
        }

        setMasterTime(time) {
          if (!this.masterVideo) return;

          // Clamp time to valid range
          time = Math.max(0, Math.min(this.commonDuration, time));

          this.isSeeking = true;

          // Set master video time
          this.masterVideo.currentTime = time;

          // Set all other videos to their corresponding times
          this.videos.forEach((video) => {
            if (video !== this.masterVideo) {
              const offset = this.syncOffsets.get(video) || 0;
              const targetTime = time + offset;
              video.currentTime = Math.max(
                0,
                Math.min(video.duration, targetTime)
              );
            }
          });

          // Update UI after a short delay to allow videos to seek
          setTimeout(() => {
            this.isSeeking = false;
            this.updateScrubber();
            this.updateTimeDisplay();
            
            // Ensure all videos are playing if they should be
            if (this.isPlaying) {
              this.videos.forEach((video) => {
                if (video.paused && !video.ended) {
                  video.play().catch(e => console.log(`Failed to resume ${this.getCameraName(video)} after seek:`, e));
                }
              });
            }
          }, 100);
        }

        setupEventListeners() {
          // Play/Pause button
          this.playPauseBtn.addEventListener('click', () => {
            this.togglePlayPause();
          });

          // Rewind button
          this.rewindBtn.addEventListener('click', () => {
            this.seekRelative(-15);
          });

          // Forward button
          this.forwardBtn.addEventListener('click', () => {
            this.seekRelative(15);
          });

          // Speed buttons
          this.speedButtons.forEach((btn) => {
            btn.addEventListener('click', () => {
              this.toggleSpeed(btn);
            });
          });

          // Scrubber
          this.scrubber.addEventListener('input', () => {
            this.isSeeking = true;
            this.seekToPercent(this.scrubber.value);
          });

          this.scrubber.addEventListener('change', () => {
            // Clear seeking flag after scrubber is released
            setTimeout(() => {
              this.isSeeking = false;
            }, 200);
          });

          // Click to zoom
          this.videoContainers.forEach((container) => {
            container.addEventListener('click', (e) => {
              if (!container.classList.contains('zoomed')) {
                this.toggleZoom(container);
              }
            });
          });

          // Keyboard shortcuts
          document.addEventListener('keydown', (e) => {
            switch (e.code) {
              case 'Space':
                e.preventDefault();
                this.togglePlayPause();
                break;
              case 'ArrowLeft':
                e.preventDefault();
                this.seekRelative(-15);
                break;
              case 'ArrowRight':
                e.preventDefault();
                this.seekRelative(15);
                break;
            }
          });

          // Listen to all videos for sync correction
          this.videos.forEach((video) => {
            video.addEventListener('seeking', () => {
              // When any video seeks, temporarily pause sync updates
              this.isSeeking = true;
            });

            video.addEventListener('seeked', () => {
              // Resume sync updates after seeking completes
              setTimeout(() => {
                this.isSeeking = false;
              }, 100);
            });

            // Add error handling
            video.addEventListener('error', (e) => {
              console.error(`Video error for ${this.getCameraName(video)}:`, e);
              
              // Immediately trigger sync correction for this video
              this.handleVideoError(video);
              
              // Try to recover by reloading the video after a short delay
              setTimeout(() => {
                this.recoverVideo(video);
              }, 500);
            });

            // Detect when video stalls
            video.addEventListener('waiting', () => {
              console.log(`Video ${this.getCameraName(video)} is waiting for data`);
            });

            // Detect when video can play again
            video.addEventListener('canplay', () => {
              console.log(`Video ${this.getCameraName(video)} can play`);
              
              // If we're playing, immediately sync this video to the correct time
              if (this.isPlaying) {
                const masterTime = this.getMasterTime();
                const offset = this.syncOffsets.get(video) || 0;
                const targetTime = masterTime + offset;
                
                // Only correct if the time difference is significant
                if (Math.abs(video.currentTime - targetTime) > 0.5) {
                  console.log(`Syncing ${this.getCameraName(video)} to correct time after canplay`);
                  video.currentTime = Math.max(0, Math.min(video.duration, targetTime));
                }
                
                // Try to resume playback
                video.play().catch(e => console.log(`Failed to resume ${this.getCameraName(video)} after canplay:`, e));
              }
            });

            // Detect when video pauses unexpectedly
            video.addEventListener('pause', () => {
              if (this.isPlaying && !this.isSeeking) {
                console.log(`Video ${this.getCameraName(video)} paused unexpectedly, resuming...`);
                
                // Check if video is stuck (not advancing) and correct immediately
                const currentTime = Date.now();
                const lastTime = this.lastVideoTimes.get(video) || 0;
                const lastTimestamp = this.lastVideoTimes.get(video + '_timestamp') || 0;
                const timeSinceLastUpdate = currentTime - lastTimestamp;
                
                // If video has been stuck for more than 1 second, correct immediately
                if (timeSinceLastUpdate > 1000 && Math.abs(video.currentTime - lastTime) < 0.1) {
                  console.log(`Video ${this.getCameraName(video)} detected as stuck, correcting immediately`);
                  this.forceSyncCorrection(video);
                } else {
                  // Just resume normally
                  const masterTime = this.getMasterTime();
                  const offset = this.syncOffsets.get(video) || 0;
                  const correctTime = masterTime + offset;
                  video.currentTime = Math.max(0, Math.min(video.duration, correctTime));
                  video.play().catch(e => console.log(`Failed to resume ${this.getCameraName(video)}:`, e));
                }
              }
            });
          });
        }

        togglePlayPause() {
          if (this.isPlaying) {
            this.pauseAll();
          } else {
            this.playAll();
          }
        }

        playAll() {
          this.videos.forEach((video) => {
            video.play().catch((e) => {
              console.log(`Play failed for ${this.getCameraName(video)}:`, e);
              // Try to recover by seeking to current master time
              const offset = this.syncOffsets.get(video) || 0;
              const targetTime = this.getMasterTime() + offset;
              video.currentTime = Math.max(0, Math.min(video.duration, targetTime));
              // Try playing again after a short delay
              setTimeout(() => {
                video.play().catch(e2 => console.log(`Retry play failed for ${this.getCameraName(video)}:`, e2));
              }, 100);
            });
          });
          this.isPlaying = true;
          this.playPauseBtn.textContent = 'Pauză';
        }

        pauseAll() {
          this.videos.forEach((video) => {
            video.pause();
          });
          this.isPlaying = false;
          this.playPauseBtn.textContent = 'Redă';
        }

        seekRelative(seconds) {
          const currentTime = this.getMasterTime();
          const newTime = currentTime + seconds;
          this.setMasterTime(newTime);
        }

        seekToPercent(percent) {
          const targetTime = (percent / 100) * this.commonDuration;
          this.setMasterTime(targetTime);
        }

        seekToStart() {
          // Start at 11:30:20 (5.33 minutes into the 10-minute interval) - 10 seconds before red area
          this.setMasterTime(5 * 60 + 20);
        }

        updateScrubber() {
          if (this.isSeeking || !this.masterVideo) return;

          const currentTime = this.getMasterTime();
          const percent = (currentTime / this.commonDuration) * 100;

          // Only update if the difference is significant to avoid jitter
          const currentValue = parseFloat(this.scrubber.value);
          if (Math.abs(currentValue - percent) > 0.5) {
            this.scrubber.value = percent;
          }
        }

        updateTimeDisplay() {
          if (!this.masterVideo) return;

          const currentTime = this.getMasterTime();

          // Convert to time of day (starting from 11:25)
          const baseTime = 11 * 3600 + 25 * 60; // 11:25:00 in seconds
          const actualTimeSeconds = baseTime + currentTime;

          const current = this.formatTimeOfDay(actualTimeSeconds);
          const total = this.formatTimeOfDay(baseTime + this.commonDuration);
          this.timeDisplay.textContent = `${current} / ${total}`;
        }

        formatTimeOfDay(seconds) {
          const hours = Math.floor(seconds / 3600);
          const mins = Math.floor((seconds % 3600) / 60);
          const secs = Math.floor(seconds % 60);
          return `${hours.toString().padStart(2, '0')}:${mins
            .toString()
            .padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        setupTimeUpdateListeners() {
          // Only listen to master video for UI updates
          this.masterVideo.addEventListener('timeupdate', () => {
            if (!this.isSeeking) {
              this.updateScrubber();
              this.updateTimeDisplay();
            }
          });

          // Start sync monitoring
          this.startSyncMonitoring();
        }

        startSyncMonitoring() {
          // Monitor sync and stuck videos every 2 seconds
          setInterval(() => {
            this.checkAndCorrectSync();
          }, this.syncCheckInterval);
        }

        checkAndCorrectSync() {
          if (this.isSeeking || !this.isPlaying || !this.masterVideo) return;

          const masterTime = this.getMasterTime();
          const currentTime = Date.now();

          // Check if it's time for a sync check
          if (currentTime - this.lastSyncCheck < this.syncCheckInterval) return;
          this.lastSyncCheck = currentTime;

          // Don't correct too frequently
          if (currentTime - this.lastCorrectionTime < this.correctionCooldown) return;

          let needsCorrection = false;
          const corrections = [];

          this.videos.forEach((video) => {
            if (video === this.masterVideo) return;

            const offset = this.syncOffsets.get(video) || 0;
            const expectedTime = masterTime + offset;
            const actualTime = video.currentTime;
            const timeDiff = Math.abs(expectedTime - actualTime);

            // Check if video is stuck (not advancing)
            const lastTime = this.lastVideoTimes.get(video) || 0;
            const timeSinceLastUpdate = currentTime - (this.lastVideoTimes.get(video + '_timestamp') || 0);
            
            // Check if video has stopped playing but should be playing
            if (this.isPlaying && video.paused && !video.ended) {
              console.log(`Video ${this.getCameraName(video)} stopped playing, resuming...`);
              // Correct the time position before resuming to prevent falling behind
              const correctTime = masterTime + offset;
              video.currentTime = Math.max(0, Math.min(video.duration, correctTime));
              video.play().catch(e => console.log(`Failed to resume ${this.getCameraName(video)}:`, e));
            }
            
            // More aggressive stuck detection - check if video hasn't advanced in 1.5 seconds
            if (timeSinceLastUpdate > 1500 && Math.abs(actualTime - lastTime) < 0.1) {
              // Video appears to be stuck
              console.log(`Video ${this.getCameraName(video)} appears stuck at ${actualTime}s (no progress for ${timeSinceLastUpdate}ms)`);
              corrections.push({
                video: video,
                targetTime: expectedTime,
                reason: 'stuck'
              });
              needsCorrection = true;
            } else if (timeDiff > this.syncTolerance && timeDiff < 10) { // Only correct if difference is reasonable (not too far off)
              // Video is out of sync but not too far off
              console.log(`Video ${this.getCameraName(video)} out of sync: expected ${expectedTime}s, got ${actualTime}s (diff: ${timeDiff}s)`);
              corrections.push({
                video: video,
                targetTime: expectedTime,
                reason: 'sync'
              });
              needsCorrection = true;
            }

            // Update last known times
            this.lastVideoTimes.set(video, actualTime);
            this.lastVideoTimes.set(video + '_timestamp', currentTime);
          });

          // Apply corrections if needed
          if (needsCorrection) {
            this.lastCorrectionTime = currentTime;
            this.applySyncCorrections(corrections);
          }
        }

        applySyncCorrections(corrections) {
          console.log(`Applying ${corrections.length} sync corrections`);
          
          // Set seeking flag to prevent UI interference
          this.isSeeking = true;
          
          corrections.forEach(({ video, targetTime, reason }) => {
            const cameraName = this.getCameraName(video);
            const container = video.closest('.video-container');
            console.log(`Correcting ${cameraName} (${reason}): ${video.currentTime}s -> ${targetTime}s`);
            
            // Show sync indicator only once per correction session
            if (container && reason === 'stuck') {
              container.classList.add('syncing');
              setTimeout(() => {
                container.classList.remove('syncing');
              }, 2000); // Hide after 2 seconds
            }
            
            // Clamp target time to video duration
            const clampedTime = Math.max(0, Math.min(video.duration, targetTime));
            
            // Set the video time
            video.currentTime = clampedTime;
            
            // If video was paused due to being stuck, try to resume playback
            if (reason === 'stuck' && this.isPlaying) {
              video.play().catch(e => console.log(`Failed to resume ${cameraName}:`, e));
            }
          });
          
          // Clear seeking flag after a delay to allow videos to seek
          setTimeout(() => {
            this.isSeeking = false;
            this.updateScrubber();
            this.updateTimeDisplay();
          }, 200);
        }

        getCameraName(video) {
          const container = video.closest('.video-container');
          return container ? container.getAttribute('data-camera') : 'Unknown';
        }

        toggleSpeed(btn) {
          const speed = parseFloat(btn.getAttribute('data-speed'));

          // Remove active class from all speed buttons
          this.speedButtons.forEach((button) => {
            button.classList.remove('active');
          });

          // Add active class to clicked button
          btn.classList.add('active');

          // Set speed for all videos
          this.videos.forEach((video) => {
            video.playbackRate = speed;
          });

          this.currentSpeed = speed;
        }

        toggleZoom(container) {
          if (this.zoomedVideo === container) {
            // Restore grid layout
            this.zoomedVideo.classList.remove('zoomed');
            this.videoContainers.forEach((c) => c.classList.remove('hidden'));
            this.zoomedVideo = null;
            this.removeZoomPanListeners();
            document.body.classList.remove('video-zoomed');
          } else {
            // Zoom to single video
            if (this.zoomedVideo) {
              this.zoomedVideo.classList.remove('zoomed');
            }
            this.zoomedVideo = container;
            container.classList.add('zoomed');
            this.videoContainers.forEach((c) => {
              if (c !== container) {
                c.classList.add('hidden');
              }
            });
            this.resetZoomPan();
            this.addZoomPanListeners(container);
            document.body.classList.add('video-zoomed');
          }
        }

        // --- Zoom and Pan Functionality ---
        addZoomPanListeners(container) {
          const wrapper = container.querySelector('.zoom-pan-wrapper');
          if (!wrapper) return;
          this.zoomScale = 1;
          this.zoomPan = { x: 0, y: 0 };
          this.updateZoomPan(wrapper);

          // Only allow zoom/pan if container is zoomed
          const isZoomed = container.classList.contains('zoomed');
          if (!isZoomed) return;

          // Minimize button handler
          const minimizeBtn = container.querySelector('.minimize-btn');
          this._minimizeHandler = (e) => {
            e.stopPropagation();
            // Reset pan position before exiting fullscreen
            this.zoomPan = { x: 0, y: 0 };
            this.zoomScale = 1;
            this.updateZoomPan(container.querySelector('.zoom-pan-wrapper'));
            this.toggleZoom(container);
          };
          minimizeBtn &&
            minimizeBtn.addEventListener('click', this._minimizeHandler);
          this._minimizeBtn = minimizeBtn;

          // Double-tap to zoom (mobile)
          this._lastTap = 0;
          this._doubleTapHandler = (e) => {
            if (e.touches && e.touches.length === 1) {
              const now = Date.now();
              if (this._lastTap && now - this._lastTap < 350) {
                // Double tap detected
                e.preventDefault();
                e.stopPropagation();
                const rect = wrapper.getBoundingClientRect();
                const tapX = e.touches[0].clientX - rect.left;
                const tapY = e.touches[0].clientY - rect.top;
                if (this.zoomScale === 1) {
                  this.setZoomScale(2, tapX, tapY, wrapper);
                } else {
                  this.setZoomScale(1, tapX, tapY, wrapper);
                }
                this._lastTap = 0;
              } else {
                this._lastTap = now;
              }
            }
          };
          wrapper.addEventListener('touchend', this._doubleTapHandler);

          // Double-click to zoom (desktop)
          this._lastClick = 0;
          this._clickTimeout = null;
          this._doubleClickHandler = (e) => {
            const now = Date.now();
            if (this._lastClick && now - this._lastClick < 350) {
              // Double click detected
              e.preventDefault();
              e.stopPropagation();
              if (this._clickTimeout) {
                clearTimeout(this._clickTimeout);
                this._clickTimeout = null;
              }
              const rect = wrapper.getBoundingClientRect();
              const clickX = e.clientX - rect.left;
              const clickY = e.clientY - rect.top;
              if (this.zoomScale === 1) {
                this.setZoomScale(2, clickX, clickY, wrapper);
              } else {
                this.setZoomScale(1, clickX, clickY, wrapper);
              }
              this._lastClick = 0;
            } else {
              this._lastClick = now;
              // Set a timeout for single click - do nothing in fullscreen
              this._clickTimeout = setTimeout(() => {
                this._clickTimeout = null;
              }, 350);
            }
          };
          wrapper.addEventListener('click', this._doubleClickHandler);

          // Mouse wheel for zoom (desktop)
          this._wheelHandler = (e) => {
            if (!container.classList.contains('zoomed')) return;
            if (e.ctrlKey) return; // let browser handle pinch-zoom
            e.preventDefault();
            const delta = e.deltaY < 0 ? 0.1 : -0.1;
            this.setZoomScale(
              this.zoomScale + delta,
              e.offsetX,
              e.offsetY,
              wrapper
            );
          };
          wrapper.addEventListener('wheel', this._wheelHandler, {
            passive: false,
          });

          // Mouse drag for pan
          this._mouseDownHandler = (e) => {
            if (!container.classList.contains('zoomed')) return;
            if (e.button !== 0) return;
            if (this.zoomScale <= 1) return; // Only allow panning when zoomed in
            // Don't prevent default here to allow double-click to work
            this.panStart = { x: e.clientX, y: e.clientY };
            this.panOrigin = { ...this.zoomPan };

            // Add a small delay before enabling panning to distinguish from clicks
            this._panTimeout = setTimeout(() => {
              this.isPanning = true;
            }, 150);
          };
          this._mouseMoveHandler = (e) => {
            if (!container.classList.contains('zoomed')) return;
            if (!this.isPanning || this.zoomScale <= 1) return; // Only pan when zoomed in
            e.preventDefault();
            const dx = e.clientX - this.panStart.x;
            const dy = e.clientY - this.panStart.y;
            this.zoomPan = {
              x: this.panOrigin.x + dx,
              y: this.panOrigin.y + dy,
            };
            this.updateZoomPan(wrapper);
          };
          this._mouseUpHandler = (e) => {
            if (this._panTimeout) {
              clearTimeout(this._panTimeout);
              this._panTimeout = null;
            }
            this.isPanning = false;
          };
          wrapper.addEventListener('mousedown', this._mouseDownHandler);
          window.addEventListener('mousemove', this._mouseMoveHandler);
          window.addEventListener('mouseup', this._mouseUpHandler);

          // Touch events for pan and pinch-zoom
          this._touchStartHandler = (e) => {
            if (!container.classList.contains('zoomed')) return;
            if (e.touches.length === 1) {
              if (this.zoomScale > 1) {
                // Only allow panning when zoomed in
                this.isPanning = true;
                this.panStart = {
                  x: e.touches[0].clientX,
                  y: e.touches[0].clientY,
                };
                this.panOrigin = { ...this.zoomPan };
              }
            } else if (e.touches.length === 2) {
              this.isPanning = false;
              this.lastTouchDistance = this.getTouchDistance(e.touches);
            }
          };
          this._touchMoveHandler = (e) => {
            if (!container.classList.contains('zoomed')) return;
            if (
              e.touches.length === 1 &&
              this.isPanning &&
              this.zoomScale > 1
            ) {
              const dx = e.touches[0].clientX - this.panStart.x;
              const dy = e.touches[0].clientY - this.panStart.y;
              this.zoomPan = {
                x: this.panOrigin.x + dx,
                y: this.panOrigin.y + dy,
              };
              this.updateZoomPan(wrapper);
            } else if (e.touches.length === 2) {
              const dist = this.getTouchDistance(e.touches);
              if (this.lastTouchDistance) {
                const delta = (dist - this.lastTouchDistance) / 200; // scale factor
                this.setZoomScale(this.zoomScale + delta, null, null, wrapper);
              }
              this.lastTouchDistance = dist;
            }
          };
          this._touchEndHandler = (e) => {
            if (e.touches.length < 2) {
              this.lastTouchDistance = null;
            }
            if (e.touches.length === 0) {
              this.isPanning = false;
            }
          };
          wrapper.addEventListener('touchstart', this._touchStartHandler, {
            passive: false,
          });
          wrapper.addEventListener('touchmove', this._touchMoveHandler, {
            passive: false,
          });
          wrapper.addEventListener('touchend', this._touchEndHandler);
        }

        removeZoomPanListeners() {
          if (!this.zoomedVideo) return;
          const wrapper = this.zoomedVideo.querySelector('.zoom-pan-wrapper');
          if (!wrapper) return;
          wrapper.removeEventListener('wheel', this._wheelHandler);
          wrapper.removeEventListener('mousedown', this._mouseDownHandler);
          window.removeEventListener('mousemove', this._mouseMoveHandler);
          window.removeEventListener('mouseup', this._mouseUpHandler);
          wrapper.removeEventListener('touchstart', this._touchStartHandler);
          wrapper.removeEventListener('touchmove', this._touchMoveHandler);
          wrapper.removeEventListener('touchend', this._touchEndHandler);
          wrapper.removeEventListener('touchend', this._doubleTapHandler);
          wrapper.removeEventListener('click', this._doubleClickHandler);
          if (this._minimizeBtn) {
            this._minimizeBtn.removeEventListener(
              'click',
              this._minimizeHandler
            );
            this._minimizeBtn = null;
          }
        }

        setZoomScale(scale, originX, originY, wrapper) {
          const prevScale = this.zoomScale;
          this.zoomScale = Math.max(
            this.zoomMin,
            Math.min(this.zoomMax, scale)
          );

          // If zooming back to scale 1, reset pan position to center the video
          if (this.zoomScale === 1) {
            this.zoomPan = { x: 0, y: 0 };
          } else {
            // Adjust pan so zoom is centered on pointer (if provided)
            if (originX !== null && originY !== null && wrapper) {
              const rect = wrapper.getBoundingClientRect();
              const dx = originX - rect.width / 2 - this.zoomPan.x;
              const dy = originY - rect.height / 2 - this.zoomPan.y;
              this.zoomPan.x -=
                (dx * (this.zoomScale - prevScale)) / this.zoomScale;
              this.zoomPan.y -=
                (dy * (this.zoomScale - prevScale)) / this.zoomScale;
            }
          }

          this.updateZoomPan(wrapper);
        }

        updateZoomPan(wrapper) {
          const video = wrapper.querySelector('video');
          if (!video) return;
          video.style.transform = `scale(${this.zoomScale}) translate(${
            this.zoomPan.x / this.zoomScale
          }px, ${this.zoomPan.y / this.zoomScale}px)`;
          video.style.transition = this.isPanning ? 'none' : 'transform 0.1s';

          // Update cursor based on zoom level
          if (this.zoomScale > 1) {
            wrapper.classList.add('can-pan');
          } else {
            wrapper.classList.remove('can-pan');
          }
        }

        resetZoomPan() {
          this.zoomScale = 1;
          this.zoomPan = { x: 0, y: 0 };
          // Reset cursor by removing can-pan class
          if (this.zoomedVideo) {
            const wrapper = this.zoomedVideo.querySelector('.zoom-pan-wrapper');
            if (wrapper) {
              wrapper.classList.remove('can-pan');
            }
          }
        }

        getTouchDistance(touches) {
          const dx = touches[0].clientX - touches[1].clientX;
          const dy = touches[0].clientY - touches[1].clientY;
          return Math.sqrt(dx * dx + dy * dy);
        }

        handleVideoError(video) {
          const cameraName = this.getCameraName(video);
          console.log(`Handling video error for ${cameraName}`);
          
          // Mark this video as needing immediate correction
          const container = video.closest('.video-container');
          if (container) {
            container.classList.add('syncing');
          }
          
          // Force immediate sync correction for this video
          this.forceSyncCorrection(video);
          
          // Remove sync indicator after a delay
          setTimeout(() => {
            if (container) {
              container.classList.remove('syncing');
            }
          }, 2000);
        }

        recoverVideo(video) {
          const cameraName = this.getCameraName(video);
          console.log(`Recovering video ${cameraName}`);
          
          // Reload the video
          video.load();
          
          // Set to correct time after metadata loads
          video.addEventListener('loadedmetadata', () => {
            const masterTime = this.getMasterTime();
            const offset = this.syncOffsets.get(video) || 0;
            const targetTime = masterTime + offset;
            video.currentTime = Math.max(0, Math.min(video.duration, targetTime));
            
            // Try to resume if we're playing
            if (this.isPlaying) {
              video.play().catch(e => console.log(`Failed to resume ${cameraName} after recovery:`, e));
            }
          }, { once: true });
        }

        forceSyncCorrection(video) {
          if (!this.masterVideo || !this.isPlaying) return;
          
          const masterTime = this.getMasterTime();
          const offset = this.syncOffsets.get(video) || 0;
          const targetTime = masterTime + offset;
          
          console.log(`Forcing sync correction for ${this.getCameraName(video)}: ${video.currentTime}s -> ${targetTime}s`);
          
          // Set seeking flag to prevent UI interference
          this.isSeeking = true;
          
          // Set the video time
          video.currentTime = Math.max(0, Math.min(video.duration, targetTime));
          
          // Try to resume playback
          video.play().catch(e => console.log(`Failed to resume ${this.getCameraName(video)} after force sync:`, e));
          
          // Clear seeking flag after a delay
          setTimeout(() => {
            this.isSeeking = false;
            this.updateScrubber();
            this.updateTimeDisplay();
          }, 200);
        }
      }

      // Initialize the viewer when the page loads
      document.addEventListener('DOMContentLoaded', () => {
        new CCTVViewer();
      });
    </script>
  </body>
</html>
